---
ST_ID: "AURORA-ST-20260202-004"
Title: "API Event Sourcing Endpoints"
Version: "1.0"
Date: "2025-02-02"
Status: "READY_TO_START"
Priority: "HIGH"
SLA: "6 hours"

# Solicitação Técnica - AURORA-ST-20260202-004

## Executive Summary
Implement FastAPI REST endpoints for Event Sourcing layer to expose event stream queries, replay functionality, and event creation through HTTP API.

## Business Context
Event Sourcing is complete but not yet accessible via API. Trading system and cache layers need HTTP endpoints to query event history, replay state, and audit events.

## Requirements

### Primary Requirements

#### 1. Event Stream Query Endpoints

**GET `/api/v1/events/stream/{aggregate_id}`**
- Retrieve all events for a specific aggregate
- Query parameters:
  - `since: Optional[datetime]` - Filter events after timestamp
  - `limit: Optional[int]` - Limit number of events (default: 100, max: 1000)
  - `event_type: Optional[str]` - Filter by event type
- Response: `List[EventDTO]`
- Status codes: 200 (success), 400 (invalid params), 404 (aggregate not found)

**GET `/api/v1/events/type/{event_type}`**
- Retrieve all events of a specific type
- Query parameters:
  - `limit: Optional[int]` - Limit results (default: 100)
  - `offset: Optional[int]` - Pagination offset (default: 0)
- Response: `List[EventDTO]`
- Status codes: 200, 400

**GET `/api/v1/events/all`**
- Retrieve all events in the system
- Query parameters:
  - `limit: Optional[int]` - Default: 50, max: 500
  - `offset: Optional[int]` - Pagination
- Response: `EventListDTO` (with count and events)
- Status codes: 200, 400

#### 2. State Reconstruction Endpoints

**GET `/api/v1/events/replay/{aggregate_id}`**
- Replay all events for aggregate to get current state
- Response: `ReplayResultDTO` (state, version, event_count, timestamp)
- Status codes: 200, 404

**GET `/api/v1/events/replay/{aggregate_id}/as-of`**
- Replay events up to a specific timestamp (temporal query)
- Query parameters:
  - `timestamp: str` - ISO format datetime (required)
- Response: `ReplayResultDTO` (with as_of timestamp)
- Status codes: 200, 400 (invalid timestamp), 404

#### 3. Event Creation Endpoints

**POST `/api/v1/events/create`**
- Create a new event in the store
- Request body: `CreateEventDTO`
  - `event_type: str` - Type of event
  - `aggregate_id: str` - Aggregate ID
  - `data: Dict[str, Any]` - Event payload
  - `user_id: Optional[str]` - User who triggered event
- Response: `EventDTO` (created event with ID and timestamp)
- Status codes: 201 (created), 400 (invalid event), 422 (unprocessable)

**POST `/api/v1/events/create-batch`**
- Create multiple events atomically
- Request body: `List[CreateEventDTO]`
- Response: `BatchCreateResultDTO` (count, created_ids, errors)
- Status codes: 201, 400, 422

#### 4. Analytics/Projection Endpoints

**GET `/api/v1/events/stats`**
- Get aggregate statistics across all events
- Response: `EventStatsDTO`
  - `total_events: int`
  - `events_by_type: Dict[str, int]`
  - `events_by_aggregate: Dict[str, int]`
  - `first_event_time: datetime`
  - `last_event_time: datetime`
- Status codes: 200

**GET `/api/v1/events/timeline/{aggregate_id}`**
- Get timeline of events for aggregate
- Response: `List[TimelineEntryDTO]`
  - `event_id: str`
  - `event_type: str`
  - `timestamp: datetime`
  - `version: int`
- Status codes: 200, 404

#### 5. Health/Monitoring Endpoints

**GET `/api/v1/events/health`**
- Check event store health
- Response: `HealthDTO`
  - `status: str` ("healthy", "degraded", "unhealthy")
  - `event_count: int`
  - `last_event_time: datetime`
  - `database_connection: bool`
- Status codes: 200, 503 (unhealthy)

### Secondary Requirements

#### 6. Data Transfer Objects (DTOs)

**EventDTO**
```python
{
  "event_id": str,
  "event_type": str,
  "aggregate_id": str,
  "timestamp": datetime,
  "data": Dict[str, Any],
  "version": int,
  "user_id": Optional[str]
}
```

**ReplayResultDTO**
```python
{
  "aggregate_id": str,
  "version": int,
  "status": str,
  "data": Dict[str, Any],
  "event_count": int,
  "created_at": datetime,
  "last_updated": datetime,
  "as_of": Optional[datetime]
}
```

**CreateEventDTO**
```python
{
  "event_type": str,
  "aggregate_id": str,
  "data": Dict[str, Any],
  "user_id": Optional[str]
}
```

#### 7. Error Handling

- **400 Bad Request**: Invalid query parameters, malformed JSON
- **404 Not Found**: Aggregate/event not found
- **422 Unprocessable Entity**: Validation errors (invalid event type, etc)
- **500 Internal Server Error**: Database errors
- **503 Service Unavailable**: Event store unhealthy

All error responses include:
```python
{
  "error": str,
  "detail": str,
  "timestamp": datetime,
  "request_id": str
}
```

#### 8. API Documentation

- OpenAPI/Swagger documentation auto-generated
- Available at `/api/v1/docs` (Swagger UI)
- Available at `/api/v1/redoc` (ReDoc)
- All endpoints documented with examples

### Non-Functional Requirements

#### Performance
- All queries return within 500ms (P95)
- Pagination for large result sets (limit 1000 max)
- Database indexes optimized for queries

#### Security
- All endpoints require authentication (JWT bearer token)
- Authorization: Admin only for batch operations
- Input validation on all parameters
- Rate limiting: 100 requests/minute per user

#### Monitoring
- Request/response logging
- Performance metrics (latency percentiles)
- Error tracking and alerting
- Event creation audit trail

#### Testing
- Unit tests for all endpoints (happy path + error cases)
- Integration tests with real database
- Load testing for pagination
- Test coverage: >= 90%

## Implementation Details

### File Structure
```
src/api/
├── events/
│   ├── __init__.py
│   ├── routes.py          (15-20 endpoints)
│   ├── schemas.py         (DTOs and Pydantic models)
│   ├── dependencies.py    (JWT auth, logging)
│   └── middleware.py      (error handling, logging)
└── main.py               (update with new routes)
```

### Technology Stack
- FastAPI 0.104.1
- Pydantic for validation
- SQLAlchemy for database
- JWT for authentication (PyJWT)
- Python 3.11

### Integration Points
- Uses `EventStore` from `src/events/event_store.py`
- Uses `EventProcessor` from `src/events/event_processor.py`
- Uses Redis cache for frequent queries (via decorator)
- Database connections via SessionLocal

### Dependencies to Add
```
python-jose==3.3.0  # JWT handling
passlib==1.7.4      # Password hashing (for future auth)
```

## Acceptance Criteria

- [ ] All 5 endpoint categories implemented (stream, replay, create, analytics, health)
- [ ] Request/response DTOs complete with validation
- [ ] Error handling with proper HTTP status codes
- [ ] OpenAPI documentation generated and accessible
- [ ] JWT authentication integrated
- [ ] All endpoints tested (unit + integration)
- [ ] Test coverage >= 90%
- [ ] Performance benchmarks met (500ms P95)
- [ ] Code reviewed and approved
- [ ] RC (Relatório Conclusão) created

## Success Metrics

| Metric | Target |
|--------|--------|
| Endpoints Implemented | 8+ |
| Unit Tests | >= 40 |
| Test Coverage | >= 90% |
| Response Time (P95) | < 500ms |
| Code Quality | PEP 8 + type hints |
| Documentation | 100% coverage |

## Risk Assessment

| Risk | Mitigation |
|------|-----------|
| Database performance | Use indexes, pagination, limits |
| Large event streams | Implement pagination, caching |
| Concurrent access | Use database transactions |
| Invalid events | Pydantic validation, factory functions |

## Timeline

- **Phase 1 (2h)**: Route structure + DTOs
- **Phase 2 (2h)**: Endpoints implementation  
- **Phase 3 (1h)**: Testing
- **Phase 4 (1h)**: Documentation + RC

**Total SLA**: 6 hours

## Governance

- **Tier**: TIER_A (API layer, user-facing)
- **Review Required**: Tech Lead + API Architect
- **Branches**: `feature/st-004-api-events`
- **Merge Target**: `main`
- **PR Review**: PSA + CEO approval

## Notes

- Event Sourcing core (ST-003) must be merged first
- PR #10 must be completed before starting
- Use existing FastAPI patterns from `src/api/main.py`
- Follow AURORA coding standards
- All timestamps in UTC/ISO format

---

**Status**: READY_TO_START  
**Created**: 2025-02-02  
**Next Step**: Create feature branch and begin implementation
